# 句末分号：你可能不了解的事实

## 热身环节

在讲述接下里的故事之前，话不多说，让我们先来做一道题练练手。

请思考下列JS语句输出结果是什么？并复制粘贴进**浏览器控制台**中运行验证。



```js
let foo=[[1,2,3],[4,5,6],[7,8,9]]
let bar=foo
[1,2,1,2,1,2].forEach(item=>console.log(item))
```

如果输出和你预期中的一样，那么恭喜你，你的JS基础非常扎实。

如果输出与你预期中的不一样，不用灰心，大多数的我们都和你是一样的预期，这个时候你可以把这段代码复制进你的JS文件中保存，然后再用Node环境去运行这个JS文件，输出可能又和你最开始的预期一样。造成这种输出的不同，并不是Node环境和浏览器运行环境的不同，而是你用**Vscode**保存时自动格式化工具帮你悄悄加上了分号。

```js
//Let‘s say it together Thank you Vscode!!!
let foo=[[1,2,3],[4,5,6],[7,8,9]];
let bar=foo;
[1,2,1,2,1,2].forEach(item=>console.log(item));
```

上面的题其实包含了两个小知识，**自动分号补全**和**逗号操作符**。

> Tips: 以下的两个知识点的标题和相关引用均有超链接跳转，可点击跳转原文



## [自动分号补全](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#自动分号补全)（[Automatic Semicolon Insertion](https://262.ecma-international.org/11.0/#sec-automatic-semicolon-insertion)）

当你没有句末分号的时候，JS解析器会尽量把新的一行纳入当前行解释，只有符合**自动分号补全**规则才会在合适的位置自动补全分号，警惕句首以  **[**  **(**  **\\**  **+**  **-**  **\`** 这六种特殊字符开头,这时候可能会被当做上一行的一部分来解析。

> 1. 当新的一行并入当前行将构成非法语句不能正确解析时，将自动插入分号
> 1. 当新行以 **}** 开头时，即代码块的结束位置，将自动插入分号
> 1. 当以**return**语句结束时, 在行末自动插入分号
> 1. 当以**break**语句结束时, 在行末自动插入分号
> 1. 当以**throw**语句结束时,在行末自动插入分号
> 1. 当以**continue**语句结束时, 在行末自动插入分号
> 1. 当以 ES6 的 **yield** 语句结尾时，在行末自动插入分号
> 1. **++**、**--** 后缀表达式作为新行的开始，在行首自动插入分号
> 1. 源代码文件末尾自动插入号
>
> ​                                                                                                                              --以上规则引用自[JS分号的一些细节](https://www.cnblogs.com/vickylinj/p/15511064.html)

下面是JS解析器解析的一个简单例子

```js
let         //当JS读到这行时并不会停止，而是继续往下
foo = 'foo' //到这行的时候，组成let foo = 'foo' 一句完整语句，进行自动分号补全，然后继续往下解析
let bar = 'bar'
/*等同于*/
let foo = 'foo'
let bar = 'bar'
```

 这个时候回头看第一个例子会发现代码会被这么解释

```js
let foo=[[1,2,3],[4,5,6],[7,8,9]]
let bar=foo
[1,2,1,2,1,2].forEach(item=>console.log(item))
/*等同于*/
let foo=[[1,2,3],[4,5,6],[7,8,9]]
let bar=foo[1,2,1,2,1,2].forEach(item=>console.log(item))
//即:[[1,2,3],[4,5,6],[7,8,9]][1,2,1,2,1,2].forEach(item=>console.log(item))
```

 简单了解完**自动分号补全**机制可以跳转第二个知识点：**逗号操作符**



## [逗号操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comma_Operator) （[Comma Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)）

> **逗号操作符** 对它的每个操作数求值（从左到右），并返回最后一个操作数的值。                            --MDN

请在控制台中输入如下的例子帮助理解

```js
(1,2,3,4,5)    // output:5 返回逗号分隔的最后一个数5
[2,4,6,8,10][0]  // output:2 这个很容易理解，数组的index为0的位置是2
[2,4,6,8,10][0,1] // output:4 前一个中括号包裹的是数组,后一个为访问数组属性下标 0,1返回1,最终输出 4
```

当你两个数组字面量连在一起的时候，后一个会被当做数组的属性访问来解释。

两个知识点结合起来之后，我们就可以明白第一个例子到底发生了什么。

```js
// 第一个例子的最终解释版本
// 即:[[1,2,3],[4,5,6],[7,8,9]][1,2,1,2,1,2].forEach(item=>console.log(item))
// 即:[[1,2,3],[4,5,6],[7,8,9]][2].forEach(item=>console.log(item))
// 即:[7,8,9].forEach(item=>console.log(item))
```



## 发生场景

上面所举的例子是可以运行的，不会在控制台里面报错中断进程。当发生突破预期行为时，不容易被识别出来。当没加分号的时候，我们平常开发中有可能会遇到以下的场景：

1. 句首以==**[**==或是==**(**==开头时，控制台会出现报错 **Cannot read properties of undefined (reading 'forEach')** 或者 **xx  is not a function**。前一个是因为句首的 ==**[**== 会把上一个变量当做对象进行属性访问，紧跟着的数组方法就可能在该属性里面找不到了，后一个是因为句首的==**(**==会把上一个变量当做函数进行函数调用。

1. 句首以==**-**==、==**+**==、==**\***==开头时，该行可能会和上一行一起当做**运算符**计算进行解析，期间还可能会发生隐式转换，不过句首以==**-**==、==**+**==、==**\***==开头的场景非常罕见。

1. 句首以==**\`**==开头时，它跟==**(**==一样，会和上一行的变量组成函数调用，使用模板字符串调用参数的函数被称作是[标签函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals#带标签的模板字符串)([Tag Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates))

   ```js
   //Simple Example
   let foo = "hello!"
   function consoleFun(x){
   	console.log(x)
   }
   consoleFun(foo)     //output==> hello world!
   consoleFun`${foo}`	//output==> ['', '']
   ```

   糟糕！有些奇怪的事情发生了，首先它可以以这种形式调用，其次输出的结果很奇怪。简略的解释的话：就是当以标签函数的形式调用时，函数会接收到该模板字符串用" **${ 变量名 }** "split而成的数组，然后再依次接收到处于**${ 变量名 }**所代表变量的值。当然这个解释很不好懂，如同费马一样，我有一个绝妙的解释方法，但是空白处太少，我写不下 。

   值得庆幸的是，句首用**反引号**（==**\`**==）开头的同样很少见，我们可以先记住一个结论，函数也可以用模板字符串直接调用。关于**标签函数**，有机会以后可以展开讨论一下。
   
   

## 灵异事件？

在我进行刷题的时候，不管在牛客还是力扣，都曾遇过奇怪的报错，代码没写错，但是自测报错了。

例如在牛客网，它的题目需要你自己来处理输入输出。它提供了一个**readline**函数来让你读取输入，然后你可以使用**console**或者**prompt**对结果进行输出。

```js
// 问题:统计字符出现的个数 eg: 输入: 'abbcd' 输出: 'a:1 b:2 c:1 d:1'
let hash={}
let str =readline()
[...str].forEach(v=>hash[v]=hash[v]?hash[v]+1:1)
console.log(Object.keys(hash).map(key=>`${key}:${hash[key]}`).join(' '))
```

一般来说，你在接收到一个字符串之后会把它转换成数组，这样你就可以来执行一些遍历操作。

当我书写完上列代码，点击自测运行时，控制台提示 **SyntaxError: Unexpected token ...**。

这时候就会有点怀疑人生了，脑子冒出了一万种想法：难道字符串不可迭代？难道展开运算符写错了？在网上一通查询无果，换了个**Api**执行来实现类似功能，稀里糊涂就过去了。最后自我安慰：当排除一切不可能的，剩下的即使再不可能，那也是真相 。一定是有灵异事件发生了！！！

```js
str.split('').forEach(v=>hash[v]=hash[v]?hash[v]+1:1)//.split('')和[...str]是相同的功能
```

现在回头再来看的话，我们就会发现，其实出问题的那行代码被解析成：

```js
let str =readline()[...str].forEach(v=>hash[v]=hash[v]?hash[v]+1:1)		
```

然后我们查阅下**MDN**关于[展开语法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax)的定义：

> **展开语法 (Spread syntax),** 可以在函数调用/数组构造时，将数组表达式或者 string 在语法层面展开；还可以在构造字面量对象时，将对象表达式按 key-value 的方式展开。(**译者注**: 字面量一般指 `[1, 2, 3]` 或者 `{name: "mdn"}` 这种简洁的构造方式)

因为作为属性访问的时候，中括号里面是不支持**展开语法**的。所以控制台才会报出语法错误，看来计算机里面的的确确是没有黑魔法的，一切看起来不可思议的东西，很有可能只是自己的知识的局限性。



##规避措施

正如代码缩进的大小是两个字符还是四个字符在网上引发持续的争论，加不加分号也在前端的圈子里也是如此。站在天平的两端的人们都互认对方是异端，我们今天不去讨论哪种方式是正确的，而是给大家介绍现成的两种解决方案。

1. ### 使用格式化工具

   我们可以使用诸如**Prettier**、**Vetur**、**Beautify**这一类代码格式化插件对代码进行格式化，甚至其实可以使用**Vscode**默认自带的格式化程序对代码进行格式化。设置一下关于分号的配置，以及在代码保存时进行自动格式化，就可以很容易的避免出现上述的问题。

   ```json
   // 例如在根目录 创建 .prettierrc文件 
   {
       "semi": true, // 格式化加上
   }
   ```

   你也可以在**Vscode**的**Setting.json**文件中进行配置。

1. ### 使用前置分号

   另外一个教派的人们觉得其实没必要加句末分号，我们只需要在句首加上防御性分号即可，会引发异常行为的字符其实不多，当句首出现上述的六个字符，只需在前面加上**防御性分号**即可。

   下面是我根据这个规则，在第三行句首加上分号。

   ```js
   let hash={}
   let str =readline()
   ;[...str].forEach(v=>hash[v]=hash[v]?hash[v]+1:1)
   console.log(Object.keys(hash).map(key=>`${key}:${hash[key]}`).join(' '))
   ```



这两种方案都有效地规避了没有加句末分号时引发的异常行为，大家可以各取所需。
